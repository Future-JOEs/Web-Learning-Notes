众所周知，函数中`this`的指向遵循**谁调指谁**原则
```js
var length = 10;
function fn(){
  console.log(this.length)
}
var obj = {
  length: 5,
  method: function(fn){
    fn()
    arguments[0]()
  }
}
obj.method(fn, 1)

// 输出结果
// 10
// 2
// 如果注释掉第一行代码 输出结果
// 0
// 2
```

这道题目出的简直精髓

首先如果不注释第一样代码，`obj`调用自己的`method`方法，传了两个参数，第一个是在全局定义的函数`fn`，第二个参数是number类型的常量

进入method，立即调用`fn`，虽然是在`obj`内的`method`中调用，但是实际上确是被window调用（**无法理解**），这是这道题的第一个坑。

再看接下来执行的`arguments[0]()`，`arguments`是一个数组，表示函数的实参列表，也就是说这个数组中包含两个元素，第一个是传进去的`fn`，第二个是传进去的常量1，然后它调用了第0个元素表示的函数，这里要知道，**方法作为数组元素被调用，函数体中的this指向数组本身**。举个例子，简单明了

```js
var arr=[
  function(){
    console.log(this)
  },
  1,
  2,
]
arr[0]()
//输出结果
[f, 1, 2]
```

这是第二个坑，如果不明白这点，或者仅仅认为`argements[0]`就是个普通的函数，并且在`obj`的`method`中调用，很容易得到错误的答案5。明白了第二个坑，那么这个时候就很自然地会去思考`aruments`中有`length`属性吗，答案当然是有，**数组必然有`length`属性啊**。传进去两个参数，那么数组长度就是2，函数调用结果就是2，如果对数组不熟悉的，可能会认为没有`length`属性，那么就会得到错误答案`undefined`

这道题如果到这个地方不再进一步研究，看起来似乎已经完美得到解决，但是，这道题还有一个隐藏很深的坑，如果注释掉第一行的声明`var length = 10`，如果不清楚内情，那么会得到答案`undefined`，上面不是说了吗，在`method`中调用传入的函数，`this`指向`window`，既然全局没有声明`length`，那么打印出来的结果肯定是`undefined`嘛，错！大错特错！这道题隐藏最深的地方是**`window`对象中是包含`length`属性的，并且初始值为0！**所以最后的结果是0和2。

